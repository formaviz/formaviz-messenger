# FORMAVIZ MESSENGER

***********
0. Logging
***********

Before we start we will use a professional logger : `console.log` or `console.error` are synchronous when the destination is a terminal or a file, so they are not suitable for production. To log our application we will use [pino](https://www.npmjs.com/package/pino) lib.

Install pino

```
npm i -S pino pino-pretty
```

Then we will define our logger in `src/logger.js` with a console transport :

```js
const pino = require('pino');

const logger = pino({
  prettyPrint: { colorize: true },
  level: process.env.LEVEL || 'info',
});

module.exports = logger;
```

As you can see, we use an environnement variable `LEVEL` to define the logging level. For development this variable is define in a `.env`.
We use the lib `env-cmd` to load this file for development.

```sh
echo "LEVEL=debug\n" >> .env
npm i -D env-cmd
```

See [npm dev script](package.json#9) to watch how to use it.

***************
1. Node Server 
***************

In order to use Slack api you need to install Slack client 
	
For installing Slack client : execute this command line : 

```
npm install @slack/client
```	
 
***************************************
2. Environment variables configuration 
***************************************


 The .env file contains default values for the environment variables needed by the server.

   * AMQP_URL : Our RabbitMQ server's address 

   * AMQP_USER_QUEUE_NAME: The RabbitMQ queue's name which receives the message to add user to a Slack channel.

   * AMQP_TRAINING_QUEUE_NAME : queue's name which receives the message to create a Slack channel.

   * AMQP_EVAL_QUEUE_NAME : queue's name which receives the evaluation message.

   * LEGACY_TOKEN: The legacy token generated by the formaviz workspace administrator.
   
****************************************   
  3. Environment variables values 
****************************************

   * AMQP_URL : Our RabbitMQ server's address 


   * AMQP_USER_QUEUE_NAME: userQueue


   * AMQP_TRAINING_QUEUE_NAME : trainingQueue


   * AMQP_EVAL_QUEUE_NAME : evalQueue


   * LEGACY_TOKEN : you can find the token in google drive file :QSI/messenger :  "Definiion des variables"	

************
4. RabbitMQ
************

Formaviz messenger use a message broker. We use RABBIT MQ. 

To install client rabbitmq [amqplib](https://www.npmjs.com/package/amqplib) :

```
npm i amqplib
```
this api allows us to connect with rabbitmq server, send a message or again consums this last.

*****************************
5. RabbitMQ How Does it work 
*****************************

RabbitMq is a messaging system for communicating between different systems. It uses the AMPQ protocol.
The Messenger API will be the consumer of messages while the API Training (Back) will be the producers.

![rabbit working](https://blog.eleven-labs.com/assets/2018-03-11-rabbitmq-partie-1-les-bases/rabbitmq-broker.jpg)

The producer is responsible for creating the message and sending it to an exchange. An exchange is a routing engine. Depending on the binding, the exchange will route to the queues.
The consumer, meanwhile, retrieves the message in the stack and then performs a treatment depending on the type of message.
In our API, it will have several types of messages:

  * Creating a formation
  * The evaluation
  * Add the user to the conversation channel
  
In order to carry out an appropriate treatment for each type of message, we will use the routing method as broadcast method.
We need to define the type of routing.

*************************
6. RabbitMQ, the routing 
*************************

   * Direct Exchange Routing
  
     ![rabbit direct routing ](https://blog.eleven-labs.com/assets/2018-03-11-rabbitmq-partie-1-les-bases/rabbitmq-exchange-direct.jpg)
     
     Direct routing sends messages to the queues based on a routing key. The routing key is a message attribute added in the message          header by the producer.
     
   * Fanout Exchange Routing
     
     The exchange distributes to all the tails corresponding to the binding.
     
     ![rabbit exchange routing ](https://blog.eleven-labs.com/assets/2018-03-11-rabbitmq-partie-1-les-bases/rabbitmq-exchange-fanout.jpg)
     
   * Topic Exchange
     
     The topic exchange redirects the message to the tails for which the "routing key" corresponding to the patterns.
     
      ![rabbit exchange routing ](https://blog.eleven-labs.com/assets/2018-03-11-rabbitmq-partie-1-les-bases/rabbitmq-exchange-topic.jpg)


We chose direct routing to simplify our code. The filtering will be done by rabbitmq and not in our code. As a result, we chose to set up for each feature a queue for direct routing. In addition, this would allow the tails not to be filled quickly.
You can find the characteristics of the stack above.

***********************************
7. How do we answer te producer ?
***********************************

To answer the producer, we will use the remote procedure call (RPC) pattern. A RPC allows you to send a message to a queue and wait for the answer.

![rpc](https://www.rabbitmq.com/img/tutorials/python-six.png)

The producer sends a message in the queue \' rpc_queue \' with the option reply_to which allows to send the answer in a queue and the key of \' correlation_id \' which makes it possible to associate the request of the producer with the response of the consumer.    
    
****************************
8. Additionnal informations
****************************
 The server's URL :  amqp://boowxrlb:L16RP-RTygwePbTrHb1uPOnsPDIPWIiq@bear.rmq.cloudamqp.com/boowxrlb

